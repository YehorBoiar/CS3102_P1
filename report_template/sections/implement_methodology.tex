\section{Implementation and Experimental Methodology}

The probe program was implemented using the provided code from the lecture week 3. The only part that I've reused were files: \textbf{UdpSocket.c/h}, and I took inspiration from \textbf{upd-client-2} that was reading a string from the terminal and sending that as a UDP packet of array of characters.

\subsection{Transmission Control and Concurrency}
The assignment asks for one probe per second and permits only one outstanding probe at any given time. To enforce this, the app uses \texttt{poll()} system call:
\begin{enumerate}
    \item \textbf{Transmission:} For each iteration, a \texttt{ProbePacket\_t} containing a sequence number, a monotonic transmit timestamp, and a magic value is constructed and sent to the remote reflector via UDP.

    \item \textbf{Reception Window:} The socket is monitored using \texttt{poll()} with a timeout of $1$ second to detect an incoming reflected datagram.

    \item \textbf{Classification:} If a correctly sized packet with a valid magic number is received within the timeout window, the RTT is computed and the probe is logged as \texttt{SUCCESS}. If no packet arrives before the timeout, the probe is marked as \texttt{LOST}. Any malformed or invalid packet is classified as \texttt{ERROR\_OR\_CORRUPT}.
\end{enumerate}

\subsection{Data Collection Setup}
I sent 1200 probes in $~20$ minutes of time. The sender was executed on \textbf{pc3-005-l}, targeting \texttt{slurpe-5} (running with the \texttt{--fullpe} flag) on \textbf{pc3-006-l}. 

The program generates structured CSV output directly using \texttt{printf}. A CSV header is printed at startup, and each probe result is formatted in comma-separated form:

\begin{verbatim}
printf("sequence_number,rtt_ms,bytes_received,status\n");
\end{verbatim}

The resulting structured output was redirected to \texttt{data.csv} for analysis part.